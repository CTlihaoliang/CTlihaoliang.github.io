<!DOCTYPE html>
<html>

<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>es6学习笔记</title>


<style type="text/css">
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}

kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb
}

* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>


</head>

<body>

<h2 id="toc_0">ES6学习笔记</h2>

<h3 id="toc_1">一、let和const</h3>

<p>let语法类似var,用来声明变量，但需注意：</p>

<ul>
<li>let声明的变量在所属的代码块内有效</li>
</ul>

<div><pre><code class="language-none">for(let i = 0;i &lt; 10;i++){
console.log(i);
}
consle.log(i);//ReferenceError</code></pre></div>

<ul>
<li>let声明的变量不存在变量提升，即必须先声明再使用，以下使用是不安全的：</li>
</ul>

<div><pre><code class="language-none">var tmp = 123;
    
if (true) {
  tmp = &#39;abc&#39;; // ReferenceError
  let tmp;
}</code></pre></div>

<ul>
<li>不允许重复声明(函数内部以及相同作用域内)</li>
</ul>

<div><pre><code class="language-none">function func(a){
    let a = 10;// ReferenceError
}
    
function func(){
    let a = 10;
    var a = 1;// ReferenceError
}</code></pre></div>

<p>const声明一个只读的常量，一旦声明，常量的值就不能改变，也就是说必须立马初始化。</p>

<ul>
<li>const声明的常量也不存在变量提升，同样存在暂时性死区</li>
<li>const实际保证的并不是变量的值不得改动，而是变量只想的那个内存地址不得改动</li>
</ul>

<div><pre><code class="language-none">const a = [];
a.push(&#39;xxx&#39;);//是合法的</code></pre></div>

<h3 id="toc_2">二、变量的解构赋值</h3>

<p>1、数组的解构赋值</p>

<p>数组的解构赋值可以理解为模式匹配，即等号左边的模式尽量去匹配等号右边的模式</p>

<div><pre><code class="language-none">let [x,y,z] = [1,2,3]
let [foo,bar] = [1];
console.log(foo)//1
console.log(bar) // undefined</code></pre></div>

<p>左侧没有被匹配的变量将会被赋值为undefined;ES6内部使用严格相等的运算符（===)来判断一个位置是否有值，所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。</p>

<p>2、对象的解构赋值</p>

<p>对象的解构是跟据左侧变量与右侧对象的同名属性进行匹配的。对象解构赋值的内部机制是先找到同名属性，然后再赋给对应的变量，真正赋值的是后者，而不是前者。</p>

<div><pre><code class="language-none">let {foo:bar} = {foo:&quot;aaa&quot;,bar:&quot;xxx&quot;}
console.log(bar)//aaa   </code></pre></div>

<p>3、字符串的解构赋值</p>

<p>字符串在解构赋值时，字符串被转换了一个类似数组的对象。</p>

<div><pre><code class="language-none">const [a,b,c,d,e] = &quot;hello&quot;;
let { length:len } = &quot;hello&quot;;
console.log(len)// 5</code></pre></div>

<p>4、数值和布尔值的解构赋值</p>

<p>数值和布尔值在解构赋值时则会先转为对象</p>

<div><pre><code class="language-none">let {toString:a} = 12;
a === Number.prototype.toString // true;
    
let {toString:a} = true;
a === Boolean.prototype.toString // true;</code></pre></div>

<p>上面的代码中，数值和布尔值的包装对象都有toString属性，因此变量a都能取到值。</p>

<p>5、函数参数的解构赋值</p>

<p>函数的参数也是可以使用解构赋值的</p>

<div><pre><code class="language-none">function add([a,b]){
    return a+b;
}
add([1,2]);//3
function move({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]</code></pre></div>

<h3 id="toc_3">解构赋值的作用</h3>

<p>1、交换变量的值</p>

<div><pre><code class="language-none">let x = 1;
let y = 2;
[x,y] = [y,x];</code></pre></div>

<p>2、可以方便的将参数和变量名对应起来</p>

<div><pre><code class="language-none">function foo([x,y,z]){ ... }
foo([1,2,3]);
function bar({x,y,z}){ ... }
bar({x:1,y:2,z:3})</code></pre></div>

<p>3、作为函数参数的默认值</p>

<div><pre><code class="language-none">function test(x = 1,y=2){ ... }</code></pre></div>

<h3 id="toc_4">三、字符串的扩展</h3>

<p>1、ES6提供几种新方法：</p>

<ul>
<li>includes():返回布尔值，表示是否找到了参数字符串</li>
<li>startsWith():返回布尔值，表示参数字符串是否在原字符串的头部</li>
<li><p>endsWith():返回布尔值，表示参数字符串是否在原字符串的尾部   </p>

<p>这三个方法都支持第二个参数，表示开始搜索的位置。</p></li>
<li><p>repeat(n):返回一个新字符串，表示将原字符串重复n次</p></li>
<li><p>padStart(n,str):字符串长度自动补全，用于头部补全，n是指定字符串的最小长度，str是用来补全的字符串，如果省略第二个参数，则用空字符串补全</p></li>
<li><p>padEnd(n,str):字符串长度自动补全，用于尾部补全，n是指定字符串的最小长度，str是用来补全的字符串，如果省略第二个参数，则用空字符串补全</p></li>
</ul>

<p>2、模板字符串</p>

<div><pre><code class="language-none"> let str = `
    &lt;ul&gt;
        &lt;li&gt;first&lt;/li&gt;
    &lt;/ul&gt;
 `</code></pre></div>

<p>这样str会原模原样输出，如果想去掉空格可以调用trim()方法。模板字符串中嵌入变量，需要将变量名写在${}之中。</p>

<h3 id="toc_5">四、数值的扩展</h3>

<p>1、ES6在Number对象上新提供几种方法:    </p>

<ul>
<li>Number.isFinite():用来检查一个数值是否为有限的,对于非数值一律返回false</li>
<li>Number.isNaN():来检查一个值是否为NaN，只有对于NaN才返回true，非NaN一律返回false</li>
<li>Number.parseInt():跟之前的全局parseInt方法一致</li>
<li>Number.parseFloat():跟之前的全局parseFloat方法一致</li>
<li>Number.isInteger():用来判断一个值是否为整数，在JavaScript内部，整数和浮点数是同样的存储方法，所以3和3.0被视为同一个值</li>
</ul>

<h3 id="toc_6">五、函数的扩展</h3>

<p>1、为函数的参数指定默认值：</p>

<div><pre><code class="language-none">    function bar(x = 1,y = 2){
        this.x = x;
        this.y = y;
    }
</code></pre></div>

<p>指定了默认值后，函数的length属性，将返回没有指定默认值的参数个数，也就是说：指定了默认值后，length属性将失真。  </p>

<p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域，例如:</p>

<div><pre><code class="language-none">var x = 1;

function f(x, y = x) {
  console.log(y);
}

f(2) // 2</code></pre></div>

<p>2、rest 参数</p>

<p>形式为（...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，改变量将多余的参数放进数组中。</p>

<div><pre><code class="language-none">function add(...values) {
  let sum = 0;
  for (var val of values) {
    sum += val;
  }
  return sum;
}
add(2, 5, 3) // 10</code></pre></div>

<p>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p>

<p>3、箭头函数</p>

<div><pre><code class="language-none">var foo = v =&gt; v;
等价于
var foo = function(v){
    return v;
}
var sum = (num1,num2) =&gt; num1 + num2;
等价于
var sum = function(num1.num2) {
    return num1 + num2;
}</code></pre></div>

<p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。使用箭头函数需要注意：<br>
1、函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。<br>
2、不可以当做构造函数 。<br>
3、不可以使用arguments对象，该对象在函数体内不存在，如果要用，可以用rest参数代替。<br>
4、不可以使用yeild命令，因此箭头函数不能用作Generator函数。</p>

<h3 id="toc_7">六、数组的扩展</h3>

<p>1、扩展运算符（...）<br>
扩展运算符是三个点（...）。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。例如：</p>

<div><pre><code class="language-none">Math.max.apply(null,[1,4,12]);
Math.max(...[1,4,12]);
Math.max(1,4,12);
</code></pre></div>

<p>合并数组    </p>

<div><pre><code class="language-none">const a = [22,33,44]    
const b = [1,...a]</code></pre></div>

<p>与结构赋值结合</p>

<div><pre><code class="language-none">const a = list[0],rest = list.slice(1);
等价于
[a,...rest] = list;</code></pre></div>

<p>将字符串转换为数组</p>

<div><pre><code class="language-none">[...&#39;hello&#39;]</code></pre></div>

<p>2、Array.from()<br>
Array.from方法用于将两类对象转为真正的数组：类似数组的对象和可遍历（iterable）的对象。常见的类似数组是将DOM操作返回的NodeList集合以及函数内部的arguments对象，Array.from都可以将它们转为正在的数组。</p>

<div><pre><code class="language-none">function foo(){
    var aa = Array.from(arguments);
}</code></pre></div>

<p>如果参数是一个真正的数组，Array.from会返回一个一模一样的新数组。</p>

<div><pre><code class="language-none">Array.from([1,2,3]) //1,2,3;</code></pre></div>

<p>任何有length属性的对象，都可以通过Array.from方法转为数组</p>

<div><pre><code class="language-none">Array.from({length:3})//[undefined,undefined,undefined]</code></pre></div>

<p>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>

<div><pre><code class="language-none">Array.from([1,2,3],(x) =&gt; x*x);//[1,4,9]</code></pre></div>

<p>3、Array.of()<br>
Array.of方法用于将一组值，转换为数组</p>

<div><pre><code class="language-none">Array.of(1,2,3) // [1,2,3]
Array.of(2); // [2]</code></pre></div>

<p>4、数组实例的find()和findIndex()<br>
数组实例的find方法，用于找出第一个符合条件的数组成员。他的参数是一个毁掉函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员，如果没有符合条件的成员，则返回undefined。</p>

<div><pre><code class="language-none">[1, 4, -5, 10].find((n) =&gt; n &lt; 0) // -5</code></pre></div>

<p>数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p>

<div><pre><code class="language-none">[1, 5, 10, 15].findIndex(function(value, index, arr) {
  return value &gt; 9;
}) // 2</code></pre></div>

<p>这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。</p>

<p>5、数组实例的fill()<br>
fill方法使用给定值，填充一个数组</p>

<div><pre><code class="language-none">[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;].fill(4); // [4,4,4]</code></pre></div>

<p>6、数组实例的entries(),keys()和values()<br>
keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p>

<p>7、数组实例的includes()<br>
Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似</p>

<div><pre><code class="language-none">for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) {
  console.log(index);
}
// 0
// 1

for (let elem of [&#39;a&#39;, &#39;b&#39;].values()) {
  console.log(elem);
}
// &#39;a&#39;
// &#39;b&#39;

for (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) {
  console.log(index, elem);
}
// 0 &quot;a&quot;
// 1 &quot;b&quot;</code></pre></div>

<p>该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。</p>

<h3 id="toc_8">七、对象的扩展</h3>

<p>1、属性的简洁表示法<br>
ES6 允许直接写入变量和函数，作为对象的属性和方法，属性名为变量名， 属性值为变量的值。这样的书写更加简洁。</p>

<div><pre><code class="language-none">let aa = &#39;xxx&#39;;
const bar = {
    name:&quot;ddd&quot;,
    aa,
    hello(){
        console.log(222);
    }
}</code></pre></div>

<p>2、属性名表达式<br>
ES6允许字面量定义对象时，用表达式作为对象的属性名，即把表达式放在方括号内。</p>

<div><pre><code class="language-none">let lastWord = &#39;last word&#39;;
const a = {
  &#39;first word&#39;: &#39;hello&#39;,

};
a[&#39;first word&#39;] // &quot;hello&quot;
a[lastWord] // &quot;world&quot;
a[&#39;last word&#39;] // &quot;world&quot;</code></pre></div>

<p>表达式还可以用于定义方法名。</p>

<div><pre><code class="language-none">let hello = &quot;foo&quot;;
let obj = {
  [hello]() {
    return &#39;hi&#39;;
  }
};
obj.foo() </code></pre></div>

<p>3、Object.is()<br>
ES5比较两个值是否相等，只有两个运算符：相等运算符和严格相等运算符。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。Object.is()则可以用来解决这个问题</p>

<p>4、Object.assign()<br>
Object.assign方法用于对象的合并，将源对象的所有可枚举属性，复制到目标对象。Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。<br>
Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。</p>

<p>注意：</p>

<ul>
<li>Object.assign方法实行的是浅拷贝，而不是深拷贝</li>
<li>如果源对象中的属性和目标对象的属性同名，则处理方法是替换而不是添加</li>
<li><p>Object.assign可以用来处理数组，但是会把数组视为对象。</p>

<div><pre><code class="language-none">Object.assign([1, 2, 3], [4, 5])// [4, 5, 3]</code></pre></div></li>
</ul>

<p>目前，有四个操作会忽略enumerable为false的属性。</p>

<ul>
<li>for...in循环：只遍历对象自身的和继承的可枚举的属性。<br></li>
<li>Object.keys()：返回对象自身的所有可枚举的属性的键名。<br></li>
<li>JSON.stringify()：只串行化对象自身的可枚举的属性。<br></li>
<li><p>Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。</p>

<p>5、Object.keys()，Object.values()，Object.entries()<br>
ES5 引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</p>

<div><pre><code class="language-none">var obj = { foo: &#39;bar&#39;, baz: 42 };
Object.keys(obj)
// [&quot;foo&quot;, &quot;baz&quot;]</code></pre></div>

<p>Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</p>

<div><pre><code class="language-none">const obj = { foo: &#39;bar&#39;, baz: 42 };
Object.values(obj)
// [&quot;bar&quot;, 42]</code></pre></div>

<p>Object.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</p>

<div><pre><code class="language-none">const obj = { foo: &#39;bar&#39;, baz: 42 };
Object.entries(obj)
// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]</code></pre></div>

<p>6、对象的扩展运算符<br>
ES2017 将这个运算符引入了对象。</p>

<div><pre><code class="language-none">let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
x // 1
y // 2
z // { a: 3, b: 4 }</code></pre></div>

<p>7、Null 传导运算符<br>
编程实务中，如果读取对象内部的某个属性，往往需要判断一下该对象是否存在，现在有更方便的写法：</p>

<div><pre><code class="language-none">obj?.name</code></pre></div>

<h3 id="toc_9">八、Set 和 Map 数据结构</h3>

<p>ES6提供新的数据结构Set。它类似于数组，但是成员值都是唯一的，没有重复的值，Set本身是一个构造函数，用来生成Set数据结构</p>

<div><pre><code class="language-none">const s = net Set();
[2,3,3,2,4,5,6].forEach(item =&gt; s.add(item));
console.log(s);//[2,3,4,5,6]</code></pre></div>

<p>Set可以很方便的用来处理数组去重操作</p>

<div><pre><code class="language-none">[...new Set(array)]</code></pre></div>

<p>向 Set 加入值的时候，不会发生类型转换，所以5和&quot;5&quot;是两个不同的值；</p>

<p>Set结构的实例有size属性，返回实例的成员总数
Set实例的方法分为两种：操作方法（操作数据）和遍历方法（用于遍历成员）：    </p>

<ul>
<li>add(value) 添加某个值，返回Set结构本身</li>
<li>delete(value) 删除某个值，返回一个布尔值，表示是否删除成功</li>
<li>has(value) 返回一个布尔值，表示该值是否为Set成员</li>
<li>clear() 清除所有成员，没有返回值</li>
</ul>

<p>Array.from 方法可以将Set结构转为数组，可以用于数组去重</p>

<div><pre><code class="language-none">function dedupe(array) {
    return Array.from(new Set(array));
}
dedupe([1, 1, 2, 3]) // [1, 2, 3]</code></pre></div>

<p>ES6还提供了新的数据结构Map，传统上Object对象是键值对的集合（Hash 结构），但是只能用字符串当作键，Map的出现打破了这种限制，各种类型的值（包括对象）都可以当作键。</p>

<div><pre><code class="language-none">const m = new Map();
const o = {p: &#39;Hello World&#39;};

m.set(o, &#39;content&#39;)
m.get(o) // &quot;content&quot;

m.has(o) // true
m.delete(o) // true
m.has(o) // false</code></pre></div>

<p>Map作为构造函数也可以接受一个数组作为参数，该数组的成员是一个个表示键值对的数组：</p>

<div><pre><code class="language-none">const map = new Map([
    [&#39;name&#39;, &#39;张三&#39;],
    [&#39;title&#39;, &#39;Author&#39;]
]);

map.size // 2
map.has(&#39;name&#39;) // true
map.get(&#39;name&#39;) // &quot;张三&quot;
map.has(&#39;title&#39;) // true
map.get(&#39;title&#39;) // &quot;Author&quot;</code></pre></div>

<p>注意如果对同一个键多次赋值，后面的值将覆盖前面的值。
只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。</p>

<div><pre><code class="language-none">const map = new Map();
map.set([&#39;a&#39;], 555);
map.get([&#39;a&#39;]) // undefined
</code></pre></div></li>
</ul>




</body>

</html>
